# Partial Model Mixins - Manual Generation Guide for LLMs

## Overview

This document serves as a comprehensive guide for Large Language Models (LLMs) to manually generate partial model mixins for Nostr event model classes. These mixins were previously auto-generated by a Dart code generator but are now manually maintained to provide more control and transparency.

## Purpose

The partial model mixins solve the problem of creating mutable, partial representations of immutable Nostr event models. They allow developers to:

1. **Create partial/draft versions** of event models where properties can be modified
2. **Generate type-safe setters** for event properties that are normally read-only
3. **Automatically derive property access patterns** from existing getter implementations
4. **Support different property types** (single values, sets, content-based)

## Manual Generation Approach

### 1. Identify Target Models

Look for model classes that have corresponding partial model classes using mixins:

```dart
class Note extends RegularModel<Note> {
  // ... model definition with getters
}

class PartialNote extends RegularPartialModel<Note> with PartialNoteMixin {
  // ... partial model implementation
}
```

### 2. Model Type Detection

Analyze the inheritance hierarchy to determine the correct base partial model class for the mixin:

- `RegularModel` → `RegularPartialModel`
- `EphemeralModel` → `EphemeralPartialModel` 
- `ReplaceableModel` → `ReplaceablePartialModel`
- `ParameterizableReplaceableModel` → `ParameterizableReplaceablePartialModel`

### 3. Property Analysis

Examine the model class getters and categorize them into three types based on their implementation:

#### A. Tag Value Properties
For getters that use `event.getFirstTagValue('tagName')`:

```dart
// Original getter:
String? get title => event.getFirstTagValue('title');

// Generated mixin methods:
String? get title => event.getFirstTagValue('title');
set title(String? value) => event.setTagValue('title', value);
```

#### B. Tag Set Properties  
For getters that use `event.getTagSetValues('tagName')`:

```dart
// Original getter:
Set<String> get hashtags => event.getTagSetValues('t');

// Generated mixin methods:
Set<String> get hashtags => event.getTagSetValues('t');
set hashtags(Set<String> value) => event.setTagValues('t', value);
void addHashtag(String? value) => event.addTagValue('t', value);
void removeHashtag(String? value) => event.removeTagWithValue('t', value);
```

#### C. Content Properties
For getters that only use `event.content`:

```dart
// Original getter:
String get text => event.content;

// Generated mixin methods:
String? get text => event.content.isEmpty ? null : event.content;
set text(String? value) => event.content = value ?? '';
```

### 4. Type Handling

The generator handles different data types automatically:

- **String values**: Direct tag value access
- **Integer values**: Automatic parsing with `int.tryParse()`
- **DateTime values**: Conversion using `.toInt()?.toDate()` and `.toSeconds().toString()`
- **Set<String>**: Multi-value tag handling with add/remove methods

### 5. Manual Generation Output Structure

For each model class, create the mixin inline in the same model file, directly before the `PartialXXX` class:

```dart
// ignore_for_file: annotate_overrides

/// Generated partial model mixin for Note
mixin PartialNoteMixin on RegularPartialModel<Note> {
  // Property getters and setters
  String? get title => event.getFirstTagValue('title');
  set title(String? value) => event.setTagValue('title', value);
  
  String? get content => event.content.isEmpty ? null : event.content;
  set content(String? value) => event.content = value ?? '';
  
  Set<String> get hashtags => event.getTagSetValues('t');
  set hashtags(Set<String> value) => event.setTagValues('t', value);
  void addHashtag(String? value) => event.addTagValue('t', value);
  void removeHashtag(String? value) => event.removeTagWithValue('t', value);
}

class PartialNote extends RegularPartialModel<Note> with PartialNoteMixin {
  // ... partial model implementation
}
```

### 6. Model Registration (CRITICAL STEP)

**After creating a new model and its partial mixin, you MUST register the model type.** This step is essential for the storage system to work properly.

Add the registration call in the appropriate initialization file (typically `lib/src/storage/initialization.dart` or similar):

```dart
Model.register<Highlight>(
  kind: 9802, // Replace with the actual Nostr kind number
  constructor: (map, ref) => Highlight.fromMap(map, ref),
  partialConstructor: (map) => PartialHighlight.fromMap(map),
);
```

**Registration Parameters:**
- `kind`: The Nostr event kind number for this model type
- `constructor`: Factory function to create the immutable model from a map
- `partialConstructor`: Factory function to create the partial model from a map

**Without proper registration:**
- Storage queries will fail
- Model relationships won't work
- Runtime exceptions will occur when trying to use the model

This registration step connects the model classes to the storage system and enables proper serialization/deserialization.

## Key Features

### Smart Property Detection
- Only generates setters for properties that actually access `event` data
- Ignores inherited properties from base model classes
- Skips synthetic or static properties

### Source Code Parsing
- Reads the actual source files to understand getter implementations
- Handles both main files and part files
- Extracts tag names and access patterns from implementation code

### Flexible Method Generation
- Creates singular add/remove methods for set properties using pluralization
- Handles nullable types appropriately
- Supports different return types with automatic conversion

## LLM Generation Instructions

### Step-by-Step Process

1. **Analyze each model class** - Look for getters that access `event` data
2. **Identify the base partial model class** - Based on inheritance hierarchy
3. **Generate appropriate mixin methods** - Following the patterns below
4. **Handle edge cases** - Skip inherited properties, handle nullable types
5. **Follow naming conventions** - Use plural/singular conversions for add/remove methods

### Important Rules

- **Only generate methods for getters that access `event` data** (not computed properties)
- **Skip inherited properties** from base model classes (`Model`, `RegularModel`, etc.)
- **Make nullable versions** of return types for setters
- **Use proper pluralization** for add/remove methods (use `pluralize` package logic)
- **Handle different data types** appropriately (String, int, DateTime, Set<String>)

### Edge Cases to Handle

- **Content-only properties**: Only generate if getter ONLY uses `event.content` (no tag fallbacks)
- **Complex getters**: Skip getters with complex logic that don't directly map to event data
- **Custom overrides**: Some partial models may override getters (like FileMetadata.appIdentifier)

### Mixin Naming Convention

- Model class: `Note` → Mixin: `PartialNoteMixin`
- Model class: `CustomData` → Mixin: `PartialCustomDataMixin`

### File Structure

All mixins should be placed inline in their respective model files with:
- Each mixin placed directly before its corresponding `PartialXXX` class
- Proper ignore directives: `// ignore_for_file: annotate_overrides`
- Each mixin separated by blank lines from the model class above
- Consistent naming: `PartialXXXMixin` for model class `XXX`

## Usage Context

This manual approach is designed for a Nostr protocol implementation where:

1. **Immutable models** represent finalized Nostr events
2. **Partial models** allow building/editing events before they're finalized  
3. **Event data** is stored in a generic `event` object with tag-based properties
4. **Type safety** is maintained through manually maintained mixins
5. **Mixins are co-located** with their corresponding model classes for better maintainability
6. **Mixins are used** via `with PartialXXXMixin` in partial model classes

This approach provides more control and transparency compared to automatic code generation while maintaining the same developer experience. By keeping mixins inline with their models, the code is more maintainable and easier to understand. 