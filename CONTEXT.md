# Models Library Development Guide

**THIS DOCUMENT MUST BE FOLLOWED ANYTIME A MODEL IS CREATED OR MODIFIED**

This comprehensive guide covers both partial model mixin generation and API documentation standards for Nostr event model classes.

---

## Part I: Partial Model Mixins - Manual Generation Guide

### Overview

This section serves as a comprehensive guide for Large Language Models (LLMs) to manually generate partial model mixins for Nostr event model classes. These mixins were previously auto-generated by a Dart code generator but are now manually maintained to provide more control and transparency.

### Purpose

The partial model mixins solve the problem of creating mutable, partial representations of immutable Nostr event models. They allow developers to:

1. **Create partial/draft versions** of event models where properties can be modified
2. **Generate type-safe setters** for event properties that are normally read-only
3. **Automatically derive property access patterns** from existing getter implementations
4. **Support different property types** (single values, sets, content-based)

### Manual Generation Approach

#### 1. Identify Target Models

Look for model classes that have corresponding partial model classes using mixins:

```dart
class Note extends RegularModel<Note> {
  // ... model definition with getters
}

class PartialNote extends RegularPartialModel<Note> with PartialNoteMixin {
  // ... partial model implementation
}
```

#### 2. Model Type Detection

Analyze the inheritance hierarchy to determine the correct base partial model class for the mixin:

- `RegularModel` → `RegularPartialModel`
- `EphemeralModel` → `EphemeralPartialModel` 
- `ReplaceableModel` → `ReplaceablePartialModel`
- `ParameterizableReplaceableModel` → `ParameterizableReplaceablePartialModel`

#### 3. Property Analysis

Examine the model class getters and categorize them into three types based on their implementation:

##### A. Tag Value Properties
For getters that use `event.getFirstTagValue('tagName')`:

```dart
// Original getter:
String? get title => event.getFirstTagValue('title');

// Generated mixin methods:
String? get title => event.getFirstTagValue('title');
set title(String? value) => event.setTagValue('title', value);
```

##### B. Tag Set Properties  
For getters that use `event.getTagSetValues('tagName')`:

```dart
// Original getter:
Set<String> get hashtags => event.getTagSetValues('t');

// Generated mixin methods:
Set<String> get hashtags => event.getTagSetValues('t');
set hashtags(Set<String> value) => event.setTagValues('t', value);
void addHashtag(String? value) => event.addTagValue('t', value);
void removeHashtag(String? value) => event.removeTagWithValue('t', value);
```

##### C. Content Properties
For getters that only use `event.content`:

```dart
// Original getter:
String get text => event.content;

// Generated mixin methods:
String? get text => event.content.isEmpty ? null : event.content;
set text(String? value) => event.content = value ?? '';
```

#### 4. Type Handling

The generator handles different data types automatically:

- **String values**: Direct tag value access (`event.setTagValue('tag', value)`)
- **Integer values**: Automatic parsing with `int.tryParse()` and `value?.toString()`
- **DateTime values**: Conversion using `.toInt()?.toDate()` and `value?.toSeconds().toString()`
- **Set<String>**: Multi-value tag handling with add/remove methods

**Note**: Always pass values directly to `setTagValue` - it handles null values internally, so no null checks needed.

#### 5. Manual Generation Output Structure

For each model class, create the mixin inline in the same model file, directly before the `PartialXXX` class:

```dart
// ignore_for_file: annotate_overrides

/// Generated partial model mixin for Note
mixin PartialNoteMixin on RegularPartialModel<Note> {
  // String tag values
  String? get title => event.getFirstTagValue('title');
  set title(String? value) => event.setTagValue('title', value);
  
  // Integer tag values
  int? get amount => int.tryParse(event.getFirstTagValue('amount') ?? '');
  set amount(int? value) => event.setTagValue('amount', value?.toString());
  
  // DateTime tag values  
  DateTime? get publishedAt => int.tryParse(event.getFirstTagValue('published_at') ?? '')?.toDate();
  set publishedAt(DateTime? value) => event.setTagValue('published_at', value?.toSeconds().toString());
  
  // Content property
  String? get content => event.content.isEmpty ? null : event.content;
  set content(String? value) => event.content = value ?? '';
  
  // Set tag values
  Set<String> get hashtags => event.getTagSetValues('t');
  set hashtags(Set<String> value) => event.setTagValues('t', value);
  void addHashtag(String? value) => event.addTagValue('t', value);
  void removeHashtag(String? value) => event.removeTagWithValue('t', value);
}

class PartialNote extends RegularPartialModel<Note> with PartialNoteMixin {
  // ... partial model implementation
}
```

#### 6. Model Registration (CRITICAL STEP)

**After creating a new model and its partial mixin, you MUST register the model type.** This step is essential for the storage system to work properly.

Add the registration call in the appropriate initialization file (typically `lib/src/storage/initialization.dart` or similar):

```dart
Model.register<Highlight>(
  kind: 9802, // Replace with the actual Nostr kind number
  constructor: (map, ref) => Highlight.fromMap(map, ref),
  partialConstructor: (map) => PartialHighlight.fromMap(map),
);
```

**Registration Parameters:**
- `kind`: The Nostr event kind number for this model type
- `constructor`: Factory function to create the immutable model from a map
- `partialConstructor`: Factory function to create the partial model from a map

**Without proper registration:**
- Storage queries will fail
- Model relationships won't work
- Runtime exceptions will occur when trying to use the model

This registration step connects the model classes to the storage system and enables proper serialization/deserialization.

### Key Features

#### Smart Property Detection
- Only generates setters for properties that actually access `event` data
- Ignores inherited properties from base model classes
- Skips synthetic or static properties

#### Source Code Parsing
- Reads the actual source files to understand getter implementations
- Handles both main files and part files
- Extracts tag names and access patterns from implementation code

#### Flexible Method Generation
- Creates singular add/remove methods for set properties using pluralization
- Handles nullable types appropriately
- Supports different return types with automatic conversion

### LLM Generation Instructions

#### Step-by-Step Process

1. **Analyze each model class** - Look for getters that access `event` data
2. **Identify the base partial model class** - Based on inheritance hierarchy
3. **Generate appropriate mixin methods** - Following the patterns below
4. **Handle edge cases** - Skip inherited properties, handle nullable types
5. **Follow naming conventions** - Use plural/singular conversions for add/remove methods

#### Important Rules

- **Only generate methods for getters that access `event` data** (not computed properties)
- **Skip inherited properties** from base model classes (`Model`, `RegularModel`, etc.)
- **Make nullable versions** of return types for setters
- **Use proper pluralization** for add/remove methods (use `pluralize` package logic)
- **Handle different data types** appropriately (String, int, DateTime, Set<String>)

#### Edge Cases to Handle

- **Content-only properties**: Only generate if getter ONLY uses `event.content` (no tag fallbacks)
- **Complex getters**: Skip getters with complex logic that don't directly map to event data
- **Custom overrides**: Some partial models may override getters (like FileMetadata.appIdentifier)

#### Mixin Naming Convention

- Model class: `Note` → Mixin: `PartialNoteMixin`
- Model class: `CustomData` → Mixin: `PartialCustomDataMixin`

#### File Structure

All mixins should be placed inline in their respective model files with:
- Each mixin placed directly before its corresponding `PartialXXX` class
- Proper ignore directives: `// ignore_for_file: annotate_overrides`
- Each mixin separated by blank lines from the model class above
- Consistent naming: `PartialXXXMixin` for model class `XXX`

### Usage Context

This manual approach is designed for a Nostr protocol implementation where:

1. **Immutable models** represent finalized Nostr events
2. **Partial models** allow building/editing events before they're finalized  
3. **Event data** is stored in a generic `event` object with tag-based properties
4. **Type safety** is maintained through manually maintained mixins
5. **Mixins are co-located** with their corresponding model classes for better maintainability
6. **Mixins are used** via `with PartialXXXMixin` in partial model classes

This approach provides more control and transparency compared to automatic code generation while maintaining the same developer experience. By keeping mixins inline with their models, the code is more maintainable and easier to understand.

---

## Part II: API Documentation Standards

All model files must have complete API documentation for every public member.

### Core Requirements

#### 1. Class Documentation
**❌ Remove:** `**Properties:**` and `**Methods:**` sections  
**✅ Include:** Purpose, Nostr kind number, special characteristics

```dart
/// A user profile event (kind 0) containing metadata about a Nostr user.
///
/// Profiles store user information like display name, bio, picture, and other
/// metadata. They are replaceable events, meaning newer profiles replace older ones.
class Profile extends ReplaceableModel<Profile> {
```

#### 2. Member Documentation Patterns

**Getters:** Describe what the property IS
```dart
/// The user's display name
String? get name => event.metadata['name'];

/// Payment amount in satoshis  
int get amount => event.metadata['amount'];
```

**Setters:** Use "Sets the..." pattern
```dart
/// Sets the application name
set name(String? value) => event.setTagValue('name', value);
```

**Utility Methods:** Use "Adds.../Removes..." patterns
```dart
/// Adds a relay URL to the distribution list
void addRelayUrl(String? value) => event.addTagValue('r', value);

/// Removes a relay URL from the distribution list
void removeRelayUrl(String? value) => event.removeTagWithValue('r', value);
```

**Constructors:** Document purpose and ALL parameters
```dart
/// Creates a new article with the specified title and content
///
/// [title] - The article title (required)
/// [content] - The full markdown content (required)
/// [publishedAt] - Optional publication timestamp
/// [slug] - Optional URL-friendly identifier (random if not provided)
PartialArticle(String title, String content, {DateTime? publishedAt, String? slug}) {
```

**Enums:** Document purpose and every value
```dart
/// Types of blossom file operations that can be authorized
enum BlossomAuthorizationType { 
  /// Get/download files
  get, 
  /// Upload new files
  upload, 
}
```

### Documentation Rules

#### Content Guidelines
- **Numbers:** Always specify units (satoshis, bytes, milliseconds)
- **Collections:** Mention item types ("Set of relay URLs", "List of public keys")  
- **Booleans:** Explain what true/false means
- **Optional values:** Explain when they might be null
- **Parameters:** Use `[paramName] - description` format

#### Language Patterns
- **Getters:** "The user's display name", "Set of relay URLs"
- **Setters:** "Sets the user's display name", "Sets the relay URLs"  
- **Add methods:** "Adds a relay URL to the distribution list"
- **Remove methods:** "Removes a relay URL from the distribution list"

### Quality Checklist

Before completing any model work:
- [ ] ❌ NO `**Properties:**` or `**Methods:**` sections in class docs
- [ ] ✅ ALL getters documented with clear purpose
- [ ] ✅ ALL setters documented with "Sets the..." pattern  
- [ ] ✅ ALL utility methods documented (add/remove operations)
- [ ] ✅ ALL constructors documented with parameter descriptions
- [ ] ✅ ALL enums and enum values documented
- [ ] ✅ Units specified for numerical values
- [ ] ✅ Consistent language patterns used throughout
- [ ] ✅ Partial model mixin generated and placed correctly
- [ ] ✅ Model registration added to initialization file
- [ ] ✅ Mixin follows proper naming conventions

### Verification Tools

```bash
# Find remaining **Properties** sections (should return nothing)
grep -r "**Properties**" lib/src/models/

# Find undocumented members
grep -B1 -A1 "get \|set " lib/src/models/*.dart | grep -v "///"

# Check for missing partial model mixins
grep -L "mixin Partial.*Mixin" lib/src/models/*.dart
```

### Coverage Requirement
- **100% documentation** of public getters, setters, methods, constructors
- **No exceptions** for "obvious" or "simple" members
- **Consistency** is more important than brevity
- **100% mixin coverage** for all models with partial model classes

### Reference Examples
- `lib/src/models/profile.dart` - Complex model with relationships
- `lib/src/models/article.dart` - Parameterizable replaceable model  
- `lib/src/models/community.dart` - Model with extensive utility methods
- `lib/src/models/blossom_authorization.dart` - Ephemeral model with enums

---

## Summary

Following these comprehensive standards ensures:
1. **Functional completeness** - All models have proper partial mixins and registration
2. **Type safety** - Generated mixins provide safe mutable access to event properties
3. **Professional documentation** - Consistent, thorough API documentation
4. **Developer experience** - Clear, predictable patterns for all model interactions
5. **System integration** - Proper registration enables storage and relationship functionality

**Remember: Both mixin generation AND documentation standards must be followed for every model.** 